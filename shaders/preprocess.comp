layout(local_size_x = 256) in;

/* input SSBOs */
layout(std430) buffer SamplesBuf {
  uint samples[];  // packed int16 pairs
};
layout(std430) buffer WindowBuf { float win[]; };
layout(std430) buffer FreqBuf   { float gFreq[]; };
layout(std430) buffer ColorBuf  { float gCol[]; };

/* output SSBOs */
layout(std430) buffer AmpBuf { float amp[]; };
layout(std430) buffer ColBuf { vec3 col[]; };

layout(rgba32f) writeonly uniform image2D LineImg;

/* uniforms */
uniform int   totalSamples;
uniform int   hop;
uniform float sampleRate;
uniform int   fftSize;   // == 2048 in this scaffold
uniform int   useLog;    // 0 / 1
uniform int   texWidth;

/* helpers */
uint brev(uint v) {
  return bitfieldReverse(v) >> 21;
}

vec3 getCol(int idx) {
  int base = idx * 4;
  return vec3(gCol[base], gCol[base + 1], gCol[base + 2]);
}

vec3 gradColor(float f) {
  float key = (useLog == 1)
    ? 200.0 * log(1.0 + f / 50.0)
    : f;
  if (key <= gFreq[0])  return getCol(0);
  if (key >= gFreq[63]) return getCol(63);
  for (int i = 0; i < 63; ++i) {
    float f1 = gFreq[i];
    float f2 = gFreq[i + 1];
    if (key >= f1 && key < f2) {
      float t = (key - f1) / (f2 - f1);
      return mix(getCol(i), getCol(i + 1), t);
    }
  }
  return getCol(63);
}

/* 2048-point radix-2 FFT */
shared vec2  stage[2048];
shared float redPwr[256];
shared float redPeak[256];
shared vec3  redCol[256];

void fft2048() {
  for (int size = 2; size <= 2048; size <<= 1) {
    int   h   = size >> 1;
    float ang = -6.28318530718 / float(size);
    barrier();
    for (
      uint tid = gl_LocalInvocationID.x;
      tid < 1024u;
      tid += 256u
    ) {
      int j   = int(tid) % h;
      int blk = int(tid) / h;
      int i0  = blk * size + j;
      int i1  = i0 + h;
      vec2 a  = stage[i0];
      vec2 b  = stage[i1];
      vec2 w  = vec2(
        cos(ang * float(j)),
        sin(ang * float(j))
      );
      vec2 t  = vec2(
        b.x * w.x - b.y * w.y,
        b.x * w.y + b.y * w.x
      );
      stage[i0] = a + t;
      stage[i1] = a - t;
    }
  }
  barrier();
}

void computemain() {
  uint winID = gl_WorkGroupID.x;
  uint start = winID * uint(hop);
  if (start + 2048u >= uint(totalSamples)) return;

  /* copy 2048 interleaved samples, mix to mono, apply window */
  float localPeak = 0.0;
  for (
    uint i = gl_LocalInvocationID.x;
    i < 2048u;
    i += 256u
  ) {
    uint word = samples[(start + i) / 2u];

    int s0 = int(word & 0xFFFFu);
    if (s0 > 32767) s0 -= 65536;
    int s1 = int((word >> 16) & 0xFFFFu);
    if (s1 > 32767) s1 -= 65536;

    float mono = (float(s0) + float(s1)) * 0.5 / 32768.0;
    localPeak  = max(localPeak, abs(mono));

    float w  = win[i];
    uint br  = bitfieldReverse(i) >> 21;
    stage[br] = vec2(mono * w, 0.0);
  }

  fft2048();

  float pwr = 0.0;
  vec3  rgb = vec3(0.0);
  for (
    uint k = gl_LocalInvocationID.x + 1u;
    k <= 1024u;
    k += 256u
  ) {
    vec2  c   = stage[k];
    float mag = dot(c, c) * 2.0 / 2048.0;
    pwr += mag;
    if (mag > 0.0) {
      float f = float(k) * sampleRate / 2048.0;
      rgb += mag * gradColor(f);
    }
  }

  /* reduction */
  uint lid = gl_LocalInvocationID.x;
  redPwr [lid] = pwr;
  redPeak[lid] = localPeak;
  redCol [lid] = rgb;
  barrier();

  for (uint s = 128u; s > 0u; s >>= 1u) {
    if (lid < s) {
      redPwr [lid] += redPwr [lid + s];
      redPeak[lid] = max(redPeak[lid], redPeak[lid + s]);
      redCol [lid] += redCol [lid + s];
    }
    barrier();
  }

  if (lid == 0u) {
    vec3 rgbFinal = redPwr[0] > 1e-12
      ? redCol[0] / redPwr[0]
      : vec3(0.0);
    int x = int(winID % uint(texWidth));
    int y = int(winID / uint(texWidth));
    imageStore(
      LineImg,
      ivec2(x, y),
      vec4(rgbFinal, redPeak[0])
    );
  }
}